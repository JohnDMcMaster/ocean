.\" SccsId = "@(#)cs.3 1.4 (Delft University of Technology) 08/26/92"
.ll 77
.hy
.TH CS 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
cs, canonicstring, fs, forgetstring \- functions to efficiently store strings
in a static heap.
.SH SYNOPSIS
 #include <sealib.h>

 STRING cs(char *somestring)

 STRING canonicstring(char *somestring)

 int fs(STRING canonstring)

 int forgetstring(STRING canonstring)

.SH DESCRIPTION
Cs() maintains a private heap containing copies of all the strings currently
known to cs(). On every call, cs() inspects this heap to see if the argument
somestring is already in the heap. If so, cs() returns a pointer to the copy in
the heap. If not, cs() copies the new string to the heap and then
returns a pointer to this copy.

Cs() internally associates a reference count with each string in the heap. When
a string is copied to the heap this reference count is initialized to 1. Any
subsequent request for storage of the same string causes cs() to increment the
reference count of this string.

Canonicstring() performs exactly the same operation as cs(); it calls cs(), so
the latter is a little bit faster, though somewhat more cryptic.

Strings no longer worth to remember can be removed from the heap by calling
fs() or forgetstring() using the canonic string to be removed as an argument.
Fs() operates by first decrementing the reference count associated with the
string to forget. Only if the count becomes zero the string is removed from
the heap.

If a program immediately stores its strings thru cs() as the strings enter the
program's environment, no subsequent calls to strcmp() are needed to test
whether two canonicized strings are equal because cs() guarantees equality if
the STRING pointers are equal. The
.IR sealib (3)
functions use this feature to speed up their search thru the data base
administration.
.SH "RETURN VALUE"
Cs() and canonicstring() return a character pointer (type STRING).
Fs() and forgetstring() return NIL if the string is not in the heap, i.e. not
canonic. Otherwise they return TRUE.
.SH "LIMITATION"
Although cs() accepts strings of any length, it does not store more than 257
chars (including terminating NULL). Consequently, two strings are considered
equal if they do not differ in any of the first 256 chars.
.SH "EXAMPLE"
This piece of code first canonicizes the string "blablah" and then immediately
forgets about it:

      if ( fs(cs("blablah")) == NIL )
         error("this can never happen...");

.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3).
.\" SccsId = "@(#)memman.3 1.4 (Delft University of Technology) 08/26/92"
.ll 77
.hy
.TH MEMMAN 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
mnew, mfree \- functions for fast allocation of small memory chunks.
.SH SYNOPSIS
 char *mnew(int size)

 void mfree(char **memblk, int size)

.SH DESCRIPTION
Mnew() returns a memory block of the requested size. The parameter
.I size
is in bytes. All bytes in the block are cleared. Mfree() returns a memory block
to the free list so that it can be used by mnew() again.

Mnew is much faster than
.IR malloc (3)
because it obtains large blocks of memory from the system by calling
.IR sbrk (2).
Each time mnew() is called it just returns a small piece of this large block.
Only once in many times the large block is exhausted, urging mnew() to call
sbrk() again.

All the sealib functions call mnew() and mfree() to deal with memory allocation
for the structures that make up the in-core seadif tree (see
.IR sealib (3)).
.SH "RETURN VALUE"
Mnew returns a pointer to the requested block. Alignment of the pointer is
guaranteed to be suitable for any data type in the C programming language.
If the requested block size is out of range, mnew() returns NIL.
.SH LIMITATION
Mnew() and mfree() do not deal with blocks larger than 256 bytes.
.SH "EXAMPLE"
Suppose we have a structure named DTYPE, then the following two #define's
provide functionality to create new objects of type DTYPE and also to get rid
of them at will:

 #define NewDtype(dptr) \\
         { \\
         (dptr)=(DTYPE *)mnew(sizeof(DTYPE)); \\
         (dptr)->field=initvalue; \\
         }

 #define FreeDtype(dptr) \\
         mfree((char **)dptr,sizeof(DTYPE))

If initvalue is 0 then the initializing statement in the NewDtype macro is
unnecessary. We don't check if mnew() returns NIL because we know at compile
time that sizeof(DTYPE) is within the permitted range.
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
malloc(3), sbrk(2), sealib(3).
.\" SccsId = "@(#)sdfattachli.3 1.6 (Delft University of Technology) 08/26/92"
.ll 77
.hy
.TH SDFATTACHLIB 3 "SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfattachlib \- bind a seadif library to a specific file.
.SH SYNOPSIS
 #include <sealib.h>

 int sdfattachlib(LIBRARYPTR lib, char *filename)
 
.SH DESCRIPTION
During normal sealib operation, calling this function should never be
necessary. However, it is provided to give the sophisticated user (i.e. hackers
and the like) enhanced control over the seadif data base.
Sdfattachlib() moves the named library from the file it is currently in to the
named file. However, the move only takes effect when the data base is closed
with
.IR sdfclose (3).

If filename does not start with a '/' or with './' sdfattachlib prepends the
value of the environment variable NEWSEADIR to filename.
If NEWSEADIR is not set nothing is prepended.

For this time only, the filename parameter can be an ordinary character string
and is not required to be canonic.
.SH WARNING
If you attach a library to a seadif file that was not opened with
.IR sdfopen (3)
sdfattachlib currently refuses to overwrite the file.
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfwrite(3), sdfopen(3), sdfclose(3), cs(3),
seadif(4).
.\" SccsId = "@(#)sdfclose.3 1.4 (Delft University of Technology) 08/26/92"
.ll 77
.hy
.TH SDFCLOSE 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfclose \- function to close a seadif data base.
.SH SYNOPSIS
 void sdfclose(void)

.SH DESCRIPTION
This function closes a seadif data base. If some cells had been written with
any of the functions described in
.IR sdfwrite (3)
then these write actions will only now update the data base. Consequently, if
you forget to call sdfclose (or if your program fails to do so because of a
crash), the data base remains unaffected. It just stays as it was when you
opened it with sdfopen().
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfwrite(3), sdfopen(3), sdfread(3), seadif(4),
cs(3), sdfattachlib(3), sdfexists(3), memman(3), sdfimage(4).
.\" SccsId = "@(#)sdfdelete.3 1.6 (Delft University of Technology) 09/20/92"
.ll 77
.hy
.TH SDFDELETE 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfdelete \- functions to delete seadif in-core memory structures.
.SH SYNOPSIS
 void sdfdeletecirport(CIRPORTPTR ccirport);

 void sdfdeletecirinst(CIRINSTPTR cirinst,int recursively);
 /* if recursively == TRUE then remove childcircuit
    if childcircuit->linkcnt becomes zero */

 void sdfdeletenetlist(NETPTR netlist);

 void sdfdeletebuslist(BUSPTR buslist);

 void sdfdeletecircuit(CIRCUITPTR circuit, int recursively);

 void sdfdeletelayout(LAYOUTPTR layout, int recursively);

 void sdfdeletelayport(LAYPORTPTR layport);

 void sdfdeleteslice(SLICEPTR slice, int recursively);

 void sdfdeletelayinst(LAYINSTPTR layinst, intrecursively);

 void sdfdeletewire(WIREPTR wire);

.SH DESCRIPTION
These functions delete in-core seadif data structures. If a seadif
datastructure has a \fIlinkcnt\fR field then the functions first decrement this
count and only if the count becomes 0 the data structure is deleted.

The data-structures participating in a hierarchy can be passed the option
\fIrecursively\fR. If TRUE it means that de data structures that are lower in
the hierarchy also must be deleted. (You don't want this parameter to be NIL.)
.SH "RETURN VALUE"
No return value.
.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
The file <libstruct.h>
.\" SccsId = "@(#)sdfexists.3 1.5 (Delft University of Technology) 12/11/92"
.ll 77
.hy
.TH SDFEXISTS 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfexistslib, sdfexistsfun, sdfexistscir, sdfexistslay \- functions to test
whether a seadif cell exists and to provide an entry in the internal hash
tables of the sealib functions.
.SH SYNOPSIS
 #include <sealib.h>

 extern LIBTABPTR thislibtab;   /* set by existslib */
 extern FUNTABPTR thisfuntab;   /* set by existsfun */
 extern CIRTABPTR thiscirtab;   /* set by existscir */
 extern LAYTABPTR thislaytab;   /* set by existslay */

 public int sdfexistslib(STRING libname)

 public int sdfexistsfun(STRING funname, STRING libname)

 public int sdfexistscir(STRING cirname, STRING funname, STRING libname)

 public int sdfexistslay(STRING layname, STRING cirname,
                         STRING funname, STRING libname)

.SH DESCRIPTION
These functions return TRUE if the named object exists in the data base,
otherwise they return NIL. In addition, if the function returns TRUE, the
corresponding global pointer
.IR thislibtab ,
.IR thisfuntab ,
.I thiscirtab
or
.I thislaytab
points to an entry in the hash tables that contains information about the
object.  To see what kind of information is currently available from the hash
tables, please inspect the data structures defined in the file <libio.h>.
.SH WARNING
As usual, the argument strings of these functions must be canonic, see
.IR cs (3).
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfread(3), sdfwrite(3), sdfremove(3), sdfopen(3),
sdfclose(3), sdfattachlib(3), cs(3), memman(3), seadif(4),
sdfimage(4).
.\"	@(#)sdfgetcwd.3 1.4 03/26/92 Delft University of Technology
.ll 77
.hy
.TH SDFGETCWD 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfgetcwd \- return the current working directory as a canonic string
.SH SYNOPSIS
 #include <sealib.h>

 STRING sdfgetcwd(void)

.SH DESCRIPTION
The function sdfgetcwd() returns the name of the current working directory as a
canonicstring. Depending on whether you are on a BSD system or not, sdfgetcwd()
calls itself either getwd() or getcwd() and then converts the result to a
canonicstring. Subsequent calls to sdfgetcwd() return pointers to the same
memory location and do not cause any more calls to getwd() or getcwd() or cs().

.SH "RETURN VALUE"
A successful call to sdfgetcwd() returns a pointer to the name of the current
working directory. On failure it returns NIL.

.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.

.SH "SEE ALSO"
cs(3), getwd(3), getcwd(3).
.\"	@(#)sdflist.3 1.5 08/26/92 Delft University of Technology
.ll 77
.hy
.TH SDFLIST 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdflistlay, sdflistcir, sdflistfun, sdflistlib \- Set of seadif calls that read
all the meta-children of an object, you know what i mean...
.SH SYNOPSIS
 #include <sealib.h>

 int sdflistlay(long what, CIRCUITPTR circuit);

 int sdflistcir(long what, FUNCTIONPTR function);

 int sdflistfun(long what, LIBRARYPTR library);

 int sdflistlib(long what);

.SH DESCRIPTION
Sdflistlay reads all the layouts associated with a circuit.
Sdflistcir reads all the circuits associated with a function.
Sdflistfun reads all the functions contained in a library.
Sdflistlib reads all the libraries known to the system.

All four functions require a first argument specifying in detail what to get
from the database. Refer to sdfread(3) to see what values are allowed for
this parameter.

.SH "RETURN VALUE"
A successful call to any of the four functions returns TRUE. On failure NIL is
returned.

.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.

.SH "SEE ALSO"
sdfread(3), sdflistall(3).
.\"	@(#)sdflistall.3 1.3 08/26/92 Delft University of Technology
.ll 77
.hy
.TH SDFLISTALL 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdflistalllay, sdflistallcir \- Set of seadif calls that read
all the meta-children of an object and their children.

.SH SYNOPSIS
 #include <sealib.h>

 int sdflistalllay(long what, CIRCUITPTR circuit);

 int sdflistallcir(long what, FUNCTIONPTR function);

.SH DESCRIPTION
Sdflistalllay reads all the layouts associated with a circuit and recursively
all the children of these layouts.  Sdflistallcir reads all the circuits
associated with a function and recursively all the children of these circuits.

Both functions require a first argument specifying in detail what to get
from the database. Refer to sdfread(3) to see what values are allowed for
this parameter.

.SH "RETURN VALUE"
A successful call to any of the functions returns TRUE. On failure NIL is
returned.

.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.

.SH "SEE ALSO"
sdfread(3), sdflist(3).
.\"	@(#)sdfmakeshapef.3 1.5 08/26/92 Delft University of Technology
.ll 77
.hy
.TH SDFMAKESHAPEF 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfmakeshapef \- Seadif call to install the shape function in a CIRCUIT structure.
.SH SYNOPSIS
 #include <sealib.h>

 int sdfmakeshapef(CIRCUITPTR circuit);

.SH DESCRIPTION
This function reads the bounding boxes of all layouts associated with a circuit
and then computes the shape function for that circuit. The result is a linear
list of structures of type SHAPEF (defined in libstruct.h). The bbx fields in
the list consist of strictly monotonously increasing bbx[HOR] values and
strictly monotonously decreasing bbx[VER] values.

A successful call to sdfmakeshapef returns the shape function in
circuit->shapef. It also leaves the list of layouts in the field
circuit->layout.  Sdfmakeshapef only reads the layout bounding boxes (the bbx
field in the LAYOUT structure), so only this minimal amount of information will
be present in the list of layouts --unless you read more layout information
yourself.

.SH "RETURN VALUE"
A successful call to sdfmakeshapef returns TRUE. On failure it returns NIL. If
no layout information is available for the circuit it still returns TRUE, but
the circuit->shapef field is left untouched.

.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.

.SH "SEE ALSO"
sdfread(3), sdflist(3).
.\" SccsId = "@(#)sdfopen.3 1.7 (Delft University of Technology) 02/05/93"
.ll 77
.hy
.TH SDFOPEN 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfopen \- function to open a seadif data base.
.SH SYNOPSIS
 #include <sealib.h>

 int sdfopen(void)

.SH DESCRIPTION
This function obtains the table of contents of the seadif data base (see
.IR sealib (3))
and stores this information in in-core hash tables. Subsequent calls to other
sealib function use these hash tables to get information about the data base
and to administrate some of their actions.

The environment variable SEALIB specifies a colon-separated list of directories
to be searched for seadif files. It is not an error if one or more directories
do not exists. If SEALIB is not set in the environment then the default value
is ".:/usr/local/lib/seadif".

The variable SEALIBWRITE can be set to a colon-separated list of directories
containing the seadif files that are allowed to be modified.  Directories that
appear in the SEALIBWRITE list and that do not occur in the SEALIB list are
ignored.  If SEALIBWRITE is not set, then all (writable) seadif files found
through SEALIB can be written with the
.IR sdfwrite (3)
functions.

.SH "RETURN VALUE"
Sdfopen() returns SDF_NOERROR on success. If parts of the database are found to
be locked SDFERROR_FILELOCK is returned. Other failures cause SDFERROR_SEADIF
to be returned.

.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.

.SH "SEE ALSO"
sealib(3), sdfwrite(3), sdfread(3), seadif(4), sdfclose(3),
cs(3), sdfattachlib(3), sdfexists(3), memman(3), sdfimage(4).
.\" SccsId = "@(#)sdfread.3 1.9 (Delft University of Technology) 08/26/92"
.ll 77
.hy
.TH SDFREAD 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfreadlib, sdfreadfun, sdfreadcir, sdfreadlay \- set of sealib routines to
read objects from the seadif data base into main memory.
.SH SYNOPSIS
 #include <sealib.h>

 extern LIBRARYPTR  thislib;
 extern FUNCTIONPTR thisfun;
 extern CIRCUITPTR  thiscir;
 extern LAYOUTPTR   thislay;

 int sdfreadlib(long what, STRING libname)

 int sdfreadfun(long what, STRING funname, STRING libname)

 int sdfreadcir(long what, STRING cirname, STRING funname,
                STRING libname)

 int sdfreadlay(long what, STRING layname, STRING cirname,
                STRING funname, STRING libname)

.SH DESCRIPTION
These functions read the named object from a seadif data base and install the
object in an in-core tree. The root of the tree is sdfroot, see
.IR sealib (3).
The data base must have been opened with the sealib function
.IR sdfopen (3).

The parameter "what" specifies what attributes of the object must be read.
Currently the following values are legal for what:

With
.IR sdfreadlib ()
the value SDFLIBBODY requests the bare library.
  SDFLIBSTAT requests the library status.
  SDFLIBALL requests all aforementioned library features.

With
.IR  sdfreadfun ()
the value SDFFUNBODY requests the bare function.
  SDFFUNSTAT requests the function status.
  SDFFUNTYPE requests the function type and
  SDFFUNALL requests everyting.

With
.IR  sdfreadcir ()
the value SDFCIRBODY requests the bare circuit.
  SDFCIRSTAT requests the circuit status.
  SDFCIRPORT requests the list of circuit ports.
  SDFCIRINST requests the list of circuit instances (children of the circuit).
  SDFCIRNETLIST requests the list of nets.
  SDFCIRBUS requests the list of buses.
  SDFCIRATTRIB requests the circuit attributes and
  SDFCIRALL requests all circuit features listed above.

Some attributes depend on other attributes. For instance the presence of the
netlist requires the presence of the port list (SDFCIRPORT) and the instance
list (SDFCIRINST) and of course the circuit body (SDFCIRBODY). The function
sdfreadcir() "knows" these dependencies and automatically adds such attributes if
the request makes it necessary.

With
.IR  sdfreadlay ()
the value SDFLAYBODY requests the bare layout.
  SDFLAYSTAT requests the layout status.
  SDFLAYPORT requests the list of layout ports. (Each layout port corresponds to a
circuit port but a circuit port may correspond to several layout ports.)
  SDFLAYSLICE requests the sliceing tree of the floorplan. This tree contains the
names and placement of all the child layouts.
  SDFLAYWIRE requests the list of all wires (rectangles) that make up the layout.
  SDFLAYBBX requests the sizes of the bounding box to be read. (This information
is actually redundant because it can be derived from the extreme values of the
rectangles in the wire list and the layout port list.)
  SDFLAYOFF requests the offset of the cell to the lower-left corner of a basic
sea-of-gates image.
  SDFLAYATTRIB requests the layout attributes (currently not supported).
  SDFLAYALL requests all layout features listed above.

As said before, the sdfread functions install the requested objects in the
sdfroot tree. In addition, one or more global variables are left to point to
the objects just read. These are the variables named
.IR thislib ,
.IR thisfun ,
.IR thiscir
and
.IR thislay .
For instance, after a succesfull call "sdfreadcir(SDFCIRALL,cnam,fnam,bnam)"
the global variable thislib points to the library named bnam, thisfun points to
the function fnam and thiscir points to the circuit cnam.

If you want to read a cell which is composed of yet other cells (for instance:
a flip-flop built from latches, the latches in turn built from nands and the
nands built from transistors) you can call the function sdfreadallcir() or
sdfreadalllay() to obtain all levels of the hierarchy in a single call. (Note:
this is not the meta hierarchy.) The manual page
.IR sdfreadall (3)
unveils the details.

The sealib functions keep a record of all the objects and attributes that have
been read into core. As a consequence, repeated calls for the same object
result only the first time in retrieving the object from the data base. The
following calls just set the global pointers to the previously read object.
This behavior is especially advantageous when a hierarchical cell is read that
at some point in its hierarchy refers a number of times to the same child cell.
Only one time needs the function sdfread retrieve this child cell from the data
base. While descending the hierarchy tree, sdfread automatically discriminates
between newly encountered cells and those that are already in core. This speeds
up the sdfread function significantly.
.SH "RETURN VALUE"
All functions return TRUE on succes and NIL on failure.
.SH "WARNINGS"
Do not forget to canonicize the cell names before passing them to sdfread. See
also
.IR sealib (3)
and
.IR cs (3).

Don't you dare to change the name of a cell. This would confuse the sealib
internal administration and invalidate the hashtables !!!
.SH "EXAMPLE"
This piece of code reads the layout (small(cmos(nand2(basic_stuff)))), calls a
user function to compute the bounding box and then writes the result back to
the data base.

  #include <sealib.h>

  main()
  {
  if (sdfopen() == NIL)
     error("cannot open data base");
  update_bbx();
  if (sdfclose() == NIL)
     error("cannot close data base");
  }

  void update_bbx()
  {
  STRING lnam,cnam,fnam,bnam;
  long   whatweneed
  short  xsize,ysize;

  lnam = cs("small"); cnam = cs("cmos");
  fnam = cs("nand2"); bnam = cs("basis_stuff");
  whatweneed = SDFLAYPORT + SDFLAYWIRE;
  if (sdfreadlay(whatweneed,lnam,cnam,fnam,bnam) == NIL)  
     error("cannot read layout");
  compute_bbx(&xsize,&ysize,thislay);
  thislay->bbx[HOR] = xsize;
  thislay->bbx[VER] = ysize;
  if (sdfwritelay(SDFLAYBBX,thislay) == NIL)
     error("cannot write layout");
  }

.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sdfreadall(3), sdflist(3), sdflistall(3), sealib(3), seadif(4),
sdfwrite(3), sdfopen(3), sdfclose(3), cs(3), sdfattachlib(3),
sdfexists(3), memman(3), sdfimage(4).
.\" SccsId = "@(#)sdfreadall.3 1.6 (Delft University of Technology) 02/05/93"
.ll 77
.hy
.TH SDFREADALL 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfreadallcir, sdfreadalllay \- set of sealib routines to read a hierarchical
subtree of objects from the seadif data base into main memory.
.SH SYNOPSIS
 #include <sealib.h>

 extern LIBRARYPTR  thislib;
 extern FUNCTIONPTR thisfun;
 extern CIRCUITPTR  thiscir;
 extern LAYOUTPTR   thislay;


 int sdfreadallcir(long what, STRING cirname,
                   STRING funname, STRING libname)

 int sdfreadalllay(long what, STRING layname, STRING cirname,
                   STRING funname, STRING libname)

.SH DESCRIPTION
These functions read the named object and recursively all its child cells from
a seadif data base and install the object and its children in an in-core tree.
The root of the tree is sdfroot, see
.IR sealib (3).
The data base must have been opened with the sealib function
.IR sdfopen (3).

The parameter "what" specifies what attributes of the object must be read.
Legal values are exactly as described in
.IR sdfread (3).
In fact, sdfreadall operates by repeatedly calling sdfread. (You could have
written sdfreadall by yourself, but we provided it for your convenience...)

The value of the global variables
.IR thislib ,
.IR thisfun ,
.I thiscir
and
.I thislay
refer to the specified parent cell, not to its children. See manual page of
sdfread for details.
.SH "RETURN VALUE"
Both functions return TRUE on succes and NIL on failure.
.SH "WARNINGS"
Do not forget to canonicize the cell names before passing them to sdfread. See
also

Don't you dare to change the name of a cell. This would confuse the sealib
internal administration and invalidate the hashtables !!!
.IR sealib (3)
and
.IR cs (3).
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sdfread(3), sealib(3), seadif(4), sdfwrite(3), sdfopen(3),
sdfclose(3), cs(3), sdfattachlib(3), sdfexists(3), memman(3),
sdfimage(4).
.\" SccsId = "@(#)sdfremove.3 1.3 (Delft University of Technology) 12/11/92"
.ll 77
.hy
.TH SDFREMOVE 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfremovelib, sdfremovefun, sdfremovecir, sdfremovelay \- functions that
remove an object from the Seadif library.
.SH SYNOPSIS
 #include <sealib.h>

 public int sdfremovelib(STRING libname)

 public int sdfremovefun(STRING funname, STRING libname)

 public int sdfremovecir(STRING cirname, STRING funname,
                         STRING libname)

 public int sdfremovelay(STRING layname, STRING cirname,
                         STRING funname, STRING libname)

.SH DESCRIPTION
These functions remove the named object from the seadf database. The removal
only takes place when
.IR sdfclose (3)
is called. Until that time,
.I sdfremove
does not prevent the programmer from accessing a cell that has been "removed".
.SH "RETURN VALUE"
The functions return TRUE for success and NIL for failure.
.SH WARNING
As usual, the argument strings of these functions must be canonic, see
.IR cs (3).
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfexists(3), sdfread(3), sdfwrite(3), sdfopen(3),
sdfclose(3), sdfattachlib(3), cs(3), memman(3), seadif(4),
sdfimage(4).
.\" SccsId = "@(#)sdftouch.3 1.2 (Delft University of Technology) 02/05/93"
.ll 77
.hy
.TH SDFTOUCH 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdftouch \- functions to set the modification date of a seadif object.
.SH SYNOPSIS

 #include <sealib.h>

 int sdftouchlay(LAYOUTPTR   lay, time_t timestamp);
 int sdftouchcir(CIRCUITPTR  cir, time_t timestamp);
 int sdftouchlib(LIBRARYPTR  lib, time_t timestamp);
 int sdftouchfun(FUNCTIONPTR fun, time_t timestamp);

.SH DESCRIPTION
If the named seadif object does not yet exist in the database it is created,
similar to sdfwrite(3), and the modification date in the Status field is
set to
.IR timestamp .

If the named seadif object already exists in the database, then
.I sdftouch
sets the modification date of the object to
.IR timestamp .
Because of run time efficiency, this modifiction date is not written to the
seadif database.
As a consequence, the programmer must call
.IR sdfwrite (3)
before closing the database, otherwise the call to
.I sdftouch
has no effect.
.SH "RETURN VALUE"
These functions return TRUE if the date could be set, NIL otherwise.
.SH AUTHOR
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sdfwrite(3), seadif(4)
.\" SccsId = "@(#)sdfwrite.3 1.5 (Delft University of Technology) 09/20/92"
.ll 77
.hy
.TH SDFWRITE 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfwritelib, sdfwritefun, sdfwritecir, sdfwritelay \- functions for updating
and creating objects in a seadif data base.
.SH SYNOPSIS
 #include <sealib.h>

 int sdfwritelib(long what, LIBRARYPTR library)

 int sdfwritefun(long what, FUNCTIONPTR function)

 int sdfwritecir(long what, CIRCUITPTR circuit)

 int sdfwritelay(long what, LAYOUTPTR layout)

.SH DESCRIPTION
These functions write the attributes specified in the parameter "what" to the
data base. If any such attribute already exists it is overwritten. The legal
values for "what" are described in
.IR sdfread (3).

If you want to write a father cell and all its children, the functions
sdfwriteallcir() and sdfwritealllay() may be exactly what you are looking for,
see the manual page
.IR sdfwriteall (3).
.SH ENVIRONMENT
SEALIBWRITE, see
.I sdfopen(3)
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfread(3), sdfwriteall(3), seadif(4), sdfopen(3),
sdfclose(3), cs(3), sdfattachlib(3), sdfexists(3), memman(3),
sdfimage(4).
.\" SccsId = "@(#)sdfwriteall.3 1.5 (Delft University of Technology) 02/05/93"
.ll 77
.hy
.TH SDFWRITEALL 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
sdfwriteallcir, sdfwritealllay \- functions for updating
and creating a hierarchical tree of cells in a seadif data base.
.SH SYNOPSIS
 #include <sealib.h>

 int sdfwriteallcir(long what, CIRCUITPTR circuit)
 int sdfwritealllay(long what, LAYOUTPTR layout)

.SH DESCRIPTION
These functions write the attributes specified in the parameter "what" to the
data base for the specified cell and for all its children. If any such
attribute already exists it is overwritten. The legal values for "what" are
described in
.IR sdfread (3).

The functions operate by repeatedly calling sdfwrite. They also administrate
which cells have been written, so that multiple instances of the same cell only
account for a single write operation.
.SH "WARNING"
For their own convenience, the functions sdfwriteallcir() and sdfwritealllay()
modify bit 15 (0x8000) of layout->flag.l and all its children.
.SH "AUTHOR"
Paul Stravers, Delft University of Technology.  E-mail address is
ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sdfwrite (3), sealib(3), sdfread(3), sdfwriteall(3), seadif(4),
sdfopen(3), sdfclose(3), cs(3), sdfattachlib(3), sdfexists(3),
memman(3), sdfimage(4).
.\" SccsId = "@(#)sealib.3 1.6 (Delft University of Technology) 06/18/93"
.ll 77
.hy
.TH SEALIB 3 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
Sealib \- set of library functions to manage a seadif data base.
.SH SYNOPSIS
#include <sealib.h>
.SH DESCRIPTION
A seadif data base basicly consists of a small number of files (typicly 1 to
20) each containing one or more libraries in the seadif language.
(The manual page
.IR seadif (4)
describes the seadif language.)  A seadif file name always end in ".sdf".  The
set of seadif files that make up a consistent data base can either be in a
single directory or in multiple directories. The user indicates which
directories belong to the database by setting the environment variable
SEALIB.  Alternative directory names are separated by a colon (:).  The
default value of SEALIB is ".:/usr/local/lib/seadif" (specifying the current
directory and /usr/local/lib/seadif to contain the seadif files that make up a
single consistent seadif data base).

The sealib library package provides a convenient means for reading and writing
the objects in a seadif data base. Sealib operates on the predefined in-core
data structures described in the file <libstruct.h> These data structures
represent a list of libraries. Each library contains a list of functions and
each function contains a hierarchical tree of circuits. In turn, each circuit
refers to a hierarchical tree of layouts. Thus the four-level meta hierarchy as
discussed in
.IR seadif (4)
is also present in memory. At the top of the meta hierarchy is the global
variable sdfroot (declared in libstruct.h). It points to the list of libraries.

Before any interaction with the database can take place it must be opened with
the sealib function
.IR sdfopen (3).
This function constructs a table of contents of the data base and stores it in
hash tables in main memory, thus enabling fast access to the data base.
Following this initialization step, the user can read data objects at any of
the four levels of meta hierarchy into main memory: libraries with
sdfreadlib(), functions with sdfreadfun(), circuits with sdfreadcir() and
layouts with the sealib function sdfreadlay().  The manual page
.IR sdfread (3)
describes the operation of these functions.
In a similar way the functions sdfwritelib(), sdfwritefun(), sdfwritecir() and
sdfwritelay() allow for data objects at any level of the meta hierarchy to be
written into the data base, see the manual page
.IR sdfwrite (3).
Before the user exits, he/she must call the function sdfclose(), as described
in
.IR sdfclose (3).
If for some reason sdfclose() is not called, the data base will not be updated
but remain as it was when it was opened by sdfopen(), even if the data base had
been "written". A pleasant consequence of this behavior is that if a program
crashes before it calls sdfclose(), the data base will not be left in a
partially updated state.

The user can acquire (read only) access to the hash tables constructed by
sdfopen() by calling any of the functions sdfexistslib(), sdfexistsfun(),
sdfexistscir() and sdfexistslay() as described in the manual page
.IR sdfexists (3).
This is especially useful when the user needs information regarding the meta
hierarchy. For instance, a question like "which layouts implement this
circuit?" could be answered by calling sdfexistscir(). For details, refer to
the appropriate manual page.

Normally it is transparent to the user in which file a particular data object
resides. The only thing the user needs to know is the seadif name of the
object, not the name of the file where the object happens to be. However, when
the user creates a new library it is not clear in which file it must be stored.
In such cases the sealib functions inspect the environment variable NEWSEALIB.
It should hold the name of the file where new libraries ought to go. If
NEWSEALIB is not set, new libraries by default go into the file
"@newsealib.sdf".

At any time, the user may force a particular library to go into a specified
file. The manual page
.IR sdfattachlib (3)
explains the details.

The sealib functions often must be passed character strings for names of seadif
objects. In order to speed up the interaction with the data base, all strings
must be canonicized by the function
.IR cs (3)
before they can be used as a parameter to a sealib function. Strings returned
by the sealib functions are guaranteed to be canonic, so they can be used as
parameter without processing by cs().
.SH "WARNINGS"
The sealib package provides for single user access only. Parts of the data base
can be shared among multiple projects as long as they are read only.
The data base was designed to be fast and disc-space efficient. As a
consequence fancy stuff like access control and version control has been left
out. If you really are in need for such features you can implement a fancy
shell around the sealib package to do it for you...
.SH "AUTHORS"
Paul Stravers and Patrick Groeneveld, Delft University of Technology.  E-mail
address is ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sdfread(3), sdfwrite(3), sdfdelete(3), sdfopen(3), sdfclose(3),
sdfattachlib(3), sdfexists(3), cs(3), memman(3), seadif(4),
sdfimage(4).
.\" SccsId = "@(#)seadif.4 1.15 (Delft University of Technology) 03/04/92"
.ll 77
.hy
.TH SEADIF 4 "THE SEADIF PROGRAMMERS MANUAL"
.SH NAME
Seadif \- language for sea-of-gates data representation.
.SH DESCRIPTION
Seadif is a language that is specially suited for data representation in a
sea-of-gates database. It essentially is a subset of the Edif (Electronic Design
Interchange Format) language version 2.0.0, but it has a number of enhancements.
These enhancements mainly deal with convenient layout representation and with
a so called "meta hierarchy". The meta hierarchy consists of four levels. At the
top are the
.I libraries,
at the second level are the
.I functions,
at the third level are the
.I circuits
and at the lowest level are the
.I layouts.
The main objective of the meta hierarchy is to provide a selection mechanism:
each function lists a number of functional equivalent circuits and each
circuit list a number of net-equivalent layouts.
.PP
The Seadif language is an "open" language. It can be extended while remaining
compatibility with the older version. The seadif I/O library
.IR sealib (3)
skips unknown language elements and processes only the elements that it
recognizes.
The following five subsections discuss the Seadif statements currently defined
and recognized by the Seadif I/O functions mentioned in
.IR sealib (3).
Meaning of the --rather informal-- syntax used below to describe the syntax of
the Seadif language is as follows.
.PP
  <statement>   is a statement or a terminal symbol like
                a <string> or a <number>, see below;
  <statement>?  means zero or one time <statement>;
  <statement>*  means zero, one or more times <statement>;
  <aa> | <bb>   means either <aa> or <bb>, not both;
  { <aa> <bb> } groups two statements <aa> and <bb> to
                syntacticly form a single statement.
.PP
All other symbols represent themselves. Spaces, tabs and newlines are all
equivalent. Left and right parenthesis do not need surrounding spaces in order
to be recognized, but other language element need either spaces or parenthesis
surrounding them.  For most statements the order in which they appear is
unimportant. This, however, is not true for arguments of the LaySlice statement
(see below).  It also is not true for terminal symbols of type <string> and
type <number>.
.PP
Terminal symbols of type <number> can be octal, decimal or hex and the format
corresponds to the C-syntax, that is, leading '0' for octal and leading '0x'
for hex. For instance, 023 = 19 = 0x13. Terminal symbols of type <string>
should be quoted with double-quotes (") and they may contain any character
except double-quote. Strictly alphanumeric strings do not require quotes but
they do require a leading percent (%) if the first position is numeric. For
instance, "2towers" is equivalent to %2towers.  (This is all very messy but it
comes with tradition...)
.PP
The following terminal symbols are <strings>s: <libraryname>, <functionname>,
<circuitname>, <cirportname>, <cirinstname>, <layinstname>, <netname>,
<busname>, <attributestring> and <layoutname>.
.PP
The following terminal symbols are <number>s: <layernumber>, <xposition>,
<yposition>, <xlength>, <ylength>, <xoffset>, <yoffset>, <mtx0>, <mtx1>,
<mtx2>, <mtx3>, <mtx4>, <mtx5>, <xleft>, <xright>, <ybottom> and <ytop>.
.PP
.I "SEADIF"
.br
The Seadif statement is the root of the meta hierarchy. It serves no other
purpose than grouping a set of libraries and image descriptions. Synopsis:

    <Seadif> ::= (Seadif <string>
                     <Status>?
                     <SeadifImage>*
                     <Library>* )
.PP
For a description of <SeadifImage> refer to
.IR sdfimage (4).
The <Status>, <SeadifImage> and <Library> statements may occur in any order.
.PP
.I "LIBRARY"
.br
A library groups a set of related functions that are available in a certain
technology. Synopsis:

    <Library> ::= (Library <libraryname>
                      <Technology>?
                      <Status>?
                      <Function>* )

    <Technology> ::= (Technology <string> )
.PP
The <Technology>, <Status> and <Function> statements may occur in any order.
.PP
.I "FUNCTION"
.br
A function groups a set of functional equivalent circuits.
Synopsis:

    <Function> ::= (Function <functionname>
                       <FunSimulate>?
                       <FunType>?
                       <Status>?
                       <Circuit>* )

    <FunType> ::= (FunType <string> )

    <FunSimulate> ::= (FunSimulate <string> )
.PP
Normally, FunSimulate refers to a procedure that simulates the behavior of the
function. FunType provides additional information for logic synthesis.  The
<FunSimulate>, <FunType>, <Status> and <Circuit> statements may occur in any
order.
.PP
.I "CIRCUIT"
.br
A circuit describes a network of (yet other) circuits that implement the
function.  A circuit also groups layouts that have identical net lists.
Synopsis:

    <Circuit> ::= (Circuit <circuitname>
                      <Status>?
                      <CirPortList>?
                      <CirInstList>?
                      <NetList>?
                      <BusList>?
                      <Attribute>?
                      <Layout>* )

    <CirPortList> ::= (CirPortList <CirPort>* )

    <CirPort> ::= (CirPort <cirportname> )

    <CirInstList> ::= (CirInstList <CirInst>* )

    <CirInst> ::= (CirInst <cirinstname> <CirCellRef>
                           <attributestring>? )

    <CirCellRef> ::= (CirCellRef <circuitname>
                                 <CirFunRef>? )

    <CirFunRef> ::= (CirFunRef <functionname> <CirLibRef>? )

    <CirLibRef> ::= (CirLibRef <libraryname> )

    <NetList> ::= (NetList <Net>* )

    <Net> ::= (Net <netname> <Joined> )

    <Joined> ::= (Joined <NetPortRef>* )

    <NetPortRef> ::= (NetPortRef <cirportname>
                                 <NetInstRef>? )

    <NetInstRef> ::= (NetInstRef <cirinstname> )

    <BusList> ::= (BusList <bus>* )

    <Bus> ::= (Bus <busname> <NetRef>* )

    <Attribute> ::= (Attribute <attributestring>? )

    <NetRef> ::= (NetRef <netname> <NetPortRef>* )
.PP
The CirPortList is the list of i/o ports ("terminals") through which the
circuit comunicates with other circuits. The CirInstList names all circuits
that are one step lower in the hierarchy (note: this is
.I not
the meta hierarchy). The NetList specifies the connections between the CirPorts
on this (parent) circuit and the CirPorts on the child circuits listed in the
CirInstList. Sometimes it is convenient to think of a set of Nets as a bus. The
Bus statement provides a means for net grouping. WARNING: the current
implementation (october 1991) disallows <NetPortRef>s in a <NetRef>.
The Attribute string specifies miscellaneous information about the circuit. For
instance, the attributes of a transistor could be "l=1.6 w=23", specifying
the channel length and width. The attributes of a circuit instance usually
override the (default) attributes of the instantiated circuit.
.PP
.I "LAYOUT"
.br
A layout statement describes the geometry of a circuit implementation.
Synopsis:

    <Layout> ::= (Layout <layoutname>
                     <Status>?
                     <LayPortList>?
                     <LayBbx>?
                     <LayOffset>?
                     {<LayInstList> | <LaySlice>}?
                     <WireList>? )

    <LayPortList> ::= (LayPortList <LayPort>* )

    <LayPort> ::= (LayPort <cirportname>
                      <PortLayer>? <LayPort>? )

    <PortLayer> ::= (PortLayer <layernumber> )

    <PortPos> ::= (PortPos <xposition> <yposition> )

    <LayBbx> ::= (LayBbx <xlength> <ylength> )

    <LayOffset> ::= (LayOffset <xoffset> <yoffset> )

    <LayInstList> ::= (LayInstList
                          <LayInst>*
                          <LaySlice>*
                          <LayInstList>* )

    <LayInst> ::= (LayInst <layinstname> <LayCellRef>
                      <Orient>? )

    <Orient> ::= (Orient <mtx0> <mtx1> <mtx2>
                         <mtx3> <mtx4> <mtx5> )

    <LayCellRef> ::= (LayCellRef <layoutname> <LayCirRef>? )

    <LayCirRef> ::= (LayCirRef <circuitname> <LayFunRef>? )

    <LayFunRef> ::= (LayFunRef <functionname> <LayLibRef>? )

    <LayLibRef> ::= (LayLibRef <libraryname> )

    <LaySlice> ::= (LaySlice {vertical | horizontal | chaos}
                       <LayInst>*
                       <LaySlice>*
                       <layInstList>* )

    <WireList> ::= (WireList <Wire>* )

    <Wire> ::= (Wire <layernumber> <xleft> <xright>
                   <ybottom> <ytop> )
.PP
The LayPortList lists for each CirPort one or more geometrical representations
(LayPorts). A LayPort occupies exactly one grid point indicated by PortPos. The
<layernumber> of the PortLayer (and also of the Wire statement) is interpreted
as follows.  If <layernumber> is positive then the indicated layer is added to
the position. If <layernumber> is negative then the layer 0 - <layernumber> is
removed from the position. Currently, the Oceanic sea-of-gates tools interpret
the layers 1, 2 and 3 as first metal, second metal and third metal. Contacts
between the image and first metal have <layernumber> 100, contacts between
first and second metal have <layernumber> 101 and contacts between second and
third metal have <layernumber> 102.  The LayBbx statement declares the bounding
box of the layout. The LayOffset specifies a shift with respect to the "basics
image", refer to
.IR sdfimage (4).
The LayInstList names the layout instances used. The LaySlice statement does
exactly the same, but it also specifies a slicing placement for the instances.
With the modifier "horizontal" the arguments of LaySlice are placed from left
to right. The modifier "vertical" specifies ordering from bottom to top.  The
modifier "chaos" does not specify any order at all -- it is equivalent to
LayInstList.  The WireList lists all the rectangles that make up the layout.
Interpretation of <layernumber> is as described above.
.SH "AUTHORS"
Patrick Groeneveld and Paul Stravers, Delft University of Technology.
E-mail address is ocean@donau.et.tudelft.nl.
.SH "SEE ALSO"
sealib(3), sdfread(3), sdfwrite(3), sdfopen(3), sdfclose(3),
sdfimage(4).
