<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>pattern.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.1.5 on Thu Sep 28 15:38:00 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>pattern.C</h1><a href="pattern.C.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">// ********************************************************</font>
00002 <font class="comment">// *  PATTERN.C                                           *</font>
00003 <font class="comment">// *    @(#)pattern.C 1.15 09/01/99 Delft University of Technology </font>
00004 <font class="comment">// ********************************************************</font>
00005 
00006 
00007 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00008 <font class="preprocessor">#include &lt;string.h&gt;</font>
00009 <font class="preprocessor">#include &lt;math.h&gt;</font>
00010 <font class="preprocessor">#include "<a class="code" href="pattern.h.html">pattern.h</a>"</font>
00011 <font class="preprocessor">#include "<a class="code" href="clst.h.html">clst.h</a>"</font>
00012 <font class="preprocessor">#ifdef APOLLO_SR10_4
</font>00013 <font class="preprocessor"></font><font class="comment">/* apollo needs MININT and MAXINT */</font>
00014 <font class="preprocessor"># include &lt;limits.h&gt;</font>
00015 <font class="preprocessor"># define MININT INT_MIN
</font>00016 <font class="preprocessor"></font><font class="preprocessor"># define MAXINT INT_MAX
</font>00017 <font class="preprocessor"></font><font class="preprocessor">#endif
</font>00018 <font class="preprocessor"></font>
00019 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00020"></a><a class="code" href="class_pattern.html#a0">00020</a>     <a class="code" href="class_pattern.html#a0">Pattern::Pattern</a>(LAYOUT *l,<a class="code" href="class__imagedesc.html">IMAGEDESC</a> *i, <font class="keywordtype">short</font> *m,<a class="code" href="class_laymap.html">LayMap</a> &amp;lMap,<font class="keywordtype">int</font> dc,<font class="keywordtype">int</font> im,<font class="keywordtype">int</font> da)
00021 <font class="comment">//</font>
00022 <font class="comment">// Constructor ,also creates complete layout map for this cell</font>
00023 <font class="comment">// after applying this matrix. </font>
00024 {
00025   matrix= <font class="keyword">new</font> <font class="keywordtype">short</font>[6];
00026   
00027   <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j=0;j&lt;6;j++)
00028     matrix[j]=m[j];
00029 
00030   doCheck=dc;
00031   isMac=im;
00032   doTransAna=da;
00033   cellname=l-&gt;name;
00034 
00035   tranMaps=NULL;
00036   
00037   <font class="keywordflow">if</font>(isMac)         <font class="comment">// hurry! we don't need to do too much..</font>
00038   {
00039                 <font class="comment">// rounding up</font>
00040     hor=(l-&gt;bbx[HOR]-i-&gt;overlap[HOR]+i-&gt;size[HOR]-1)/i-&gt;size[HOR];
00041     ver=(l-&gt;bbx[VER]-i-&gt;overlap[VER]+i-&gt;size[VER]-1)/i-&gt;size[VER];
00042   }
00043   <font class="keywordflow">else</font>
00044   {
00045                 <font class="comment">// first lets determine if we don't have to </font>
00046                 <font class="comment">// add a special offset to move rotated cell</font>
00047                 <font class="comment">// to the origin (0,0) </font>
00048     <font class="keywordtype">int</font> coX,coY;
00049 
00050     findNewLeftBottom(l-&gt;bbx[HOR],l-&gt;bbx[VER],matrix,coX,coY);
00051     
00052                 <font class="comment">// if this difference is more than basic cell</font>
00053                 <font class="comment">// size  move it</font>
00054     <font class="keywordflow">if</font>(abs(coX) &gt; i-&gt;size[HOR])
00055     {
00056       matrix[B1]-=(coX/i-&gt;size[HOR])*i-&gt;size[HOR];    
00057     }
00058     
00059     <font class="keywordflow">if</font>(abs(coY) &gt; i-&gt;size[VER])
00060     {
00061       matrix[B2]-=(coY/i-&gt;size[VER])*i-&gt;size[VER];    
00062     }
00063     
00064     
00065     
00066     scan(matrix,l,i,lMap);
00067   }
00068 }<font class="comment">// Pattern::Pattern  //</font>
00069 
00070 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00071"></a><a class="code" href="class_pattern.html#a1">00071</a>                <a class="code" href="class_pattern.html#a1">Pattern::~Pattern</a>()
00072 <font class="comment">//</font>
00073 <font class="comment">//</font>
00074 {
00075   <font class="keywordflow">if</font>(tranMaps!=NULL)
00076     <font class="keyword">delete</font> tranMaps;
00077 
00078   <font class="keyword">delete</font> matrix;
00079 
00080 }<font class="comment">// Pattern::~Pattern  //</font>
00081 
00082 <font class="comment">//--------------------------------------------------------------</font>
<a name="l00083"></a><a class="code" href="class_pattern.html#c0">00083</a> <font class="keywordtype">void</font>  <a class="code" href="class_pattern.html#c0">Pattern::scan</a>(<font class="keywordtype">short</font>* mtx,LAYOUT *lPtr,<a class="code" href="class__imagedesc.html">IMAGEDESC</a> *iPtr,<a class="code" href="class_laymap.html">LayMap</a> &amp;lMap)
00084 <font class="comment">//</font>
00085 <font class="comment">//  Performs a scan of all wire points for this layout and</font>
00086 <font class="comment">//  child instances and creates cluster patterns after applying</font>
00087 <font class="comment">//  transformation </font>
00088 <font class="comment">//  mtx - transformation matrix for parrent cell. It may be different than </font>
00089 <font class="comment">//        "matrix" for this pattern which is for the top level cell</font>
00090 {
00091   <font class="keywordtype">int</font> hor = iPtr-&gt;size[HOR],
00092       ver = iPtr-&gt;size[VER],
00093       **stamp = iPtr-&gt;stamp;
00094 
00095   <font class="keywordflow">if</font>(doTransAna &amp;&amp; tranMaps == NULL) <font class="comment">// if requested and that's a first</font>
00096   {                 <font class="comment">// call create empty transparency map</font>
00097     noOfLayers=iPtr-&gt;numlayers;
00098     tranMaps = <font class="keyword">new</font> <a class="code" href="class_transparency.html">Transparency</a>[noOfLayers];
00099     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0;i&lt;noOfLayers;i++)
00100       tranMaps[i]=Transparency(lPtr-&gt;bbx[HOR],lPtr-&gt;bbx[VER]);
00101     markPowerLines(iPtr);
00102   }
00103 
00104   <font class="keywordflow">for</font>(SLICE *slPtr = lPtr-&gt;slice;slPtr != NULL;slPtr=slPtr-&gt;next)
00105     scanSlice(mtx,slPtr,iPtr,lMap);
00106 
00107   <font class="keywordflow">for</font>(WIRE *wPtr=lPtr-&gt;wire;wPtr!= NULL;wPtr=wPtr-&gt;next)
00108   {
00109     <font class="keywordtype">short</font>  out[4];                   <font class="comment">// wire after transformation</font>
00110     layerType layer;
00111 
00112     <a class="code" href="mtx.C.html#a5">mtxapplytocrd</a>(out,wPtr-&gt;crd,mtx);
00113     <font class="keywordflow">if</font> (out[XL] &gt; out[XR])           <font class="comment">// after transformation relation between</font>
00114     {                                <font class="comment">// points may change</font>
00115       <font class="keywordtype">int</font> tmp=out[XL];
00116       out[XL]=out[XR];
00117       out[XR]=tmp;
00118     }  
00119     <font class="keywordflow">if</font> (out[YB] &gt; out[YT])
00120     {
00121       <font class="keywordtype">int</font> tmp=out[YB];
00122       out[YB]=out[YT];
00123       out[YT]=tmp;
00124     }  
00125 
00126     layer=<a class="code" href="phil.h.html#a15">recognizeLayer</a>(wPtr-&gt;layer);
00127     
00128     <font class="keywordtype">int</font> x,y;
00129 
00130     <font class="keywordflow">for</font>(x=out[XL];x&lt;=out[XR];x++)
00131       <font class="keywordflow">for</font>(y=out[YB];y&lt;=out[YT];y++)
00132       {
00133     <a class="code" href="class_clst.html">Clst</a> &amp;newClst=*<font class="keyword">new</font> Clst(x,y,hor,ver,stamp,lMap,layer,matrix,doCheck);
00134                        <font class="comment">// Cluster with critical points list</font>
00135                        <font class="comment">// which come from metal segments on mirror</font>
00136                        <font class="comment">// axis if doCheck == 1</font>
00137 
00138     <font class="keywordflow">if</font>(doTransAna &amp;&amp; wPtr-&gt;layer &lt; 100)
00139     {                       <font class="comment">// that's not a via</font>
00140       <a class="code" href="class_transparency.html">Transparency</a> &amp;tm=tranMaps[wPtr-&gt;layer-1];
00141       
00142       <font class="keywordflow">if</font> (y &lt; tm.sizeVer &amp;&amp; x &lt;tm.sizeHor)
00143       {
00144         tm.verGridMap[y]=0x1;
00145         tm.horGridMap[x]=0x1;
00146       }
00147       <font class="keywordflow">else</font>
00148         cerr &lt;&lt; <font class="stringliteral">"Warning: is you bounding box right? (cell "</font> 
00149          &lt;&lt; cellname &lt;&lt; <font class="stringliteral">" )"</font> &lt;&lt; endl;
00150         
00151     }
00152 
00153     <a class="code" href="class_clst.html">Clst</a> &amp;oldClst = (<a class="code" href="class_clst.html">Clst</a>&amp;)findItem( newClst );
00154     
00155     <font class="comment">// to clusters are equal if they have the same bottom</font>
00156     <font class="comment">// left coord.</font>
00157     
00158     <font class="keywordflow">if</font>(oldClst == NOITEM  )  <font class="comment">// first point in this cluster</font>
00159       add(newClst);
00160     <font class="keywordflow">else</font>
00161     {                           <font class="comment">// we must only mark new sector</font>
00162 
00163       oldClst |= newClst;
00164       <font class="keyword">delete</font> (<font class="keywordtype">void</font>*)&amp;newClst;
00165     }  
00166 
00167       }
00168   }
00169 }<font class="comment">// Pattern::scan  //</font>
00170 
00171 <font class="comment">//--------------------------------------------------------------</font>
<a name="l00172"></a><a class="code" href="class_pattern.html#c1">00172</a> <font class="keywordtype">void</font>  <a class="code" href="class_pattern.html#c1">Pattern::scanSlice</a>(<font class="keywordtype">short</font>* mtx,SLICE *slPtr,<a class="code" href="class__imagedesc.html">IMAGEDESC</a> *iPtr,<a class="code" href="class_laymap.html">LayMap</a> &amp;lMap)
00173 <font class="comment">//</font>
00174 <font class="comment">// Searching slicing structures. </font>
00175 <font class="comment">// mtx - transformation matrix for parrent cell. </font>
00176 {
00177    <font class="keywordflow">if</font> (<font class="keyword">this</font> == NIL)
00178    {
00179       cerr &lt;&lt; <font class="stringliteral">"Help\n"</font> &lt;&lt; flush;
00180    }
00181   <font class="keywordflow">if</font>(slPtr-&gt;chld_type == SLICE_CHLD)
00182   {
00183     <font class="keywordflow">for</font>(SLICE *cslPtr=slPtr-&gt;chld.slice;cslPtr != NULL;cslPtr=cslPtr-&gt;next)
00184       scanSlice(mtx,cslPtr,iPtr,lMap);
00185   }
00186   <font class="keywordflow">else</font>
00187   { 
00188     <font class="keywordflow">for</font>(LAYINST *liPtr=slPtr-&gt;chld.layinst;liPtr!=NULL;liPtr=liPtr-&gt;next)
00189       <font class="keywordflow">if</font>(strstr(liPtr-&gt;layout-&gt;name,"Tmp_Cell_")==NULL ) <font class="comment">// don't consider </font>
00190                                                      <font class="comment">// nelsis's tmp cells</font>
00191       {
00192     <font class="keywordtype">short</font> out[6],
00193           *mtxb=liPtr-&gt;mtx;
00194                 <font class="comment">// transformation for this cell is a multiplication</font>
00195                 <font class="comment">// of transfomation of parrent and transformation</font>
00196                 <font class="comment">// of child within parrent</font>
00197     
00198     out[A11] = mtx[A11]*mtxb[A11] + mtx[A12]*mtxb[A21];
00199     out[A12] = mtx[A11]*mtxb[A12] + mtx[A12]*mtxb[A22];
00200     out[A21] = mtx[A21]*mtxb[A11] + mtx[A22]*mtxb[A21];
00201     out[A22] = mtx[A21]*mtxb[A12] + mtx[A22]*mtxb[A22];
00202     out[B1]  = mtx[A11]*mtxb[B1]  + mtx[A12]*mtxb[B2] + mtx[B1];
00203     out[B2]  = mtx[A21]*mtxb[B1]  + mtx[A22]*mtxb[B2] + mtx[B2];
00204 
00205     scan(out,liPtr-&gt;layout,iPtr,lMap);  
00206       }
00207       <font class="keywordflow">else</font>
00208       {
00209     cerr &lt;&lt; <font class="stringliteral">"\n Layouts cannot be build of nelsis's temporary cells\n"</font>;
00210     <a class="code" href="usrlib.h.html#a12">usrErr</a>(<font class="stringliteral">"Pattern::scanSlice"</font>,EINPDAT);
00211       }
00212 
00213   }
00214   
00215 }<font class="comment">// Pattern::scanSlice  //</font>
00216 
00217 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00218"></a><a class="code" href="pattern.C.html#a15">00218</a>          layerType <a class="code" href="phil.h.html#a15">recognizeLayer</a>(<font class="keywordtype">short</font> layer)
00219 <font class="comment">//</font>
00220 <font class="comment">//</font>
00221 {
00222   layerType l;
00223 
00224   <font class="keywordflow">switch</font> (layer)
00225     {
00226     <font class="keywordflow">case</font> 100:
00227       l = ViaLayer;
00228       <font class="keywordflow">break</font>;
00229     <font class="keywordflow">case</font> 1:
00230       l = Metal1Layer;  
00231       <font class="keywordflow">break</font>;
00232     <font class="keywordflow">case</font> 2:
00233       l = Metal2Layer;  
00234       <font class="keywordflow">break</font>;
00235     <font class="keywordflow">case</font> 101:
00236       l = MetalsViaLayer;  
00237       <font class="keywordflow">break</font>;
00238     <font class="keywordflow">default</font>:
00239       l = Metal2Layer;
00240     }
00241   <font class="keywordflow">return</font> l;
00242 
00243 }<font class="comment">// recognizeLayer  //</font>
00244 
00245 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00246"></a><a class="code" href="class_pattern.html#a6">00246</a>                <font class="keywordtype">void</font>  <a class="code" href="class_pattern.html#a6">Pattern::addCriticals</a>(<a class="code" href="class_laymap.html">LayMap</a> &amp;lMap)
00247 <font class="comment">//</font>
00248 <font class="comment">// Adds critical points to each cluster.</font>
00249 {
00250   <a class="code" href="class_listiterator.html">ListIterator</a> cIter(*<font class="keyword">this</font>);
00251   <font class="keywordtype">int</font> x1=MAXINT,x2=MININT,
00252       y1=MAXINT,y2=MININT;
00253 
00254   <font class="keywordflow">for</font>(;(<a class="code" href="class_item.html">Item</a>&amp;)cIter != NOITEM;cIter++)
00255   {
00256     <a class="code" href="class_clst.html">Clst</a> &amp;clstRef = (<a class="code" href="class_clst.html">Clst</a>&amp;)(<a class="code" href="class_item.html">Item</a>&amp;)cIter;
00257     
00258     <font class="keywordflow">if</font> (clstRef.cX &lt; x1) 
00259       x1=clstRef.cX;
00260     <font class="keywordflow">if</font> (clstRef.cX &gt; x2)
00261       x2=clstRef.cX;
00262     <font class="keywordflow">if</font> (clstRef.cY &lt; y1) 
00263       y1=clstRef.cY;
00264     <font class="keywordflow">if</font> (clstRef.cY &gt; y2)
00265       y2=clstRef.cY;
00266 
00267   }
00268   <font class="comment">// now x1,x2,y1,y2 contain cluster coordinates of bounding box</font>
00269 
00270   <font class="keywordtype">int</font> hor=lMap.getHor(),
00271       ver=lMap.getVer();
00272     <font class="keywordtype">int</font> i,j;
00273 
00274     <font class="keywordflow">for</font>(i=x1;i&lt;=x2;i++)
00275         <font class="keywordflow">for</font>(j=y1;j&lt;=y2;j++)
00276     {
00277       <a class="code" href="class_clst.html">Clst</a> &amp;newClst=*<font class="keyword">new</font> Clst(i,j,hor,ver);
00278                                 
00279                                  <font class="comment">// adding critical points from mirror axis</font>
00280 
00281 
00282       
00283       <a class="code" href="class_clst.html">Clst</a> &amp;oldClst = (<a class="code" href="class_clst.html">Clst</a>&amp;)findItem( newClst );
00284       
00285       <font class="comment">// to clusters are equal if they have the same bottom</font>
00286       <font class="comment">// left coord.</font>
00287       
00288       <font class="keywordflow">if</font>(oldClst == NOITEM  )  <font class="comment">// first point in this cluster</font>
00289       {
00290     lMap.addCriticalPoints(newClst,matrix);
00291     add(newClst);
00292       }
00293       <font class="keywordflow">else</font>
00294       {                           <font class="comment">// we must only mark new sector</font>
00295                               <font class="comment">// and add critical points</font>
00296 
00297     lMap.addCriticalPoints(oldClst,matrix);
00298     <font class="keyword">delete</font> (<font class="keywordtype">void</font>*)&amp;newClst;
00299       }  
00300       
00301 
00302     }
00303 
00304 
00305 }<font class="comment">// Pattern::addCriticals  //</font>
00306 
00307 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00308"></a><a class="code" href="class_pattern.html#a7">00308</a>                <font class="keywordtype">void</font>  <a class="code" href="class_pattern.html#a7">Pattern::removeUnnessesery</a>(<a class="code" href="class_imagemap.html">ImageMap</a> &amp;iMap)
00309 <font class="comment">//</font>
00310 <font class="comment">// removes unnessesery critical points which are laying on metal layer on</font>
00311 <font class="comment">// mirror axis between two sectors of the same cell.</font>
00312 <font class="comment">// </font>
00313 {
00314   <a class="code" href="class_listiterator.html">ListIterator</a> clstIter( *<font class="keyword">this</font>);
00315 
00316   <font class="keywordflow">for</font>(;(<a class="code" href="class_item.html">Item</a>&amp;)clstIter != NOITEM;clstIter++)
00317   {
00318     <a class="code" href="class_clst.html">Clst</a>&amp; clstRef=(<a class="code" href="class_clst.html">Clst</a>&amp;)(<a class="code" href="class_item.html">Item</a>&amp;)clstIter;
00319     <a class="code" href="class_listiterator.html">ListIterator</a> criIter(clstRef.criticalPoints );
00320 
00321     <font class="keywordflow">for</font>(;(<a class="code" href="class_item.html">Item</a>&amp;)criIter != NOITEM;criIter++)
00322     {
00323       <a class="code" href="class_cripoint.html">CriPoint</a> &amp;test = (<a class="code" href="class_cripoint.html">CriPoint</a>&amp;)(<a class="code" href="class_item.html">Item</a>&amp;)criIter;
00324       clusterMapType nb=iMap.recognizeNeighbors(test.x,test.y);
00325       
00326       <font class="keywordflow">if</font> (nb != 0 &amp;&amp; (nb &amp; clstRef.pattern)==nb)
00327       {
00328     clstRef.criticalPoints.remove(test);
00329       }
00330     }
00331   }
00332 }<font class="comment">// Pattern::removeUnnessesery  //</font>
00333 
00334 
00335 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00336"></a><a class="code" href="class_pattern.html#c2">00336</a> <font class="keywordtype">void</font> <a class="code" href="class_pattern.html#c2">Pattern::markPowerLines</a>(<a class="code" href="class__imagedesc.html">IMAGEDESC</a>* iPtr)
00337 <font class="comment">//</font>
00338 <font class="comment">// This routine marks power lines as described in iPtr into tranMaps.</font>
00339 {
00340   <a class="code" href="class__powerline.html">POWERLINE</a> *pPtr=iPtr-&gt;powerlines;
00341 
00342   <font class="keywordflow">for</font>(;pPtr!=NULL;pPtr=pPtr-&gt;next)
00343   {
00344     <a class="code" href="class_transparency.html">Transparency</a> &amp;tRef=tranMaps[pPtr-&gt;layer];
00345 
00346     <font class="keywordflow">if</font>(iPtr-&gt;routeorient[pPtr-&gt;layer] == HOR)
00347     {
00348       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0;i&lt;tRef.sizeHor;i++)
00349     tRef.horGridMap[i]=0x1;
00350 
00351       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j=pPtr-&gt;row_or_column;j&lt;tRef.sizeVer;j+=iPtr-&gt;size[VER])
00352     tRef.verGridMap[j]=0x1;
00353     }
00354     <font class="keywordflow">else</font>
00355     {
00356       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0;i&lt;tRef.sizeVer;i++)
00357     tRef.verGridMap[i]=0x1;
00358       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j=pPtr-&gt;row_or_column;j&lt;tRef.sizeHor;j+=iPtr-&gt;size[HOR])
00359     tRef.horGridMap[j]=0x1;
00360     }
00361   }
00362 }<font class="comment">// Pattern::markPowerLines  //</font>
00363 
00364 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00365"></a><a class="code" href="class_pattern.html#a12">00365</a> <font class="keywordtype">void</font> <a class="code" href="class_pattern.html#a12">Pattern::findNewLeftBottom</a>(<font class="keywordtype">int</font> x,<font class="keywordtype">int</font> y,<font class="keywordtype">short</font> *mx,<font class="keywordtype">int</font>&amp; cx,<font class="keywordtype">int</font>&amp; cy)
00366 <font class="comment">//</font>
00367 <font class="comment">// This routine tries to find out what will be the new left bottom corner </font>
00368 <font class="comment">// of a cell with (x,y) dimensions after applying the matrix. The result</font>
00369 <font class="comment">// is returned in (cx,cx);</font>
00370 {
00371   <font class="keywordtype">short</font> in[4],out[4];
00372   
00373   in[XL]=in[YB]=0;      <font class="comment">// left bottom corner</font>
00374   in[XR]=x;                 <font class="comment">// right-top corner</font>
00375   in[YT]=y;
00376   
00377   <a class="code" href="mtx.C.html#a5">mtxapplytocrd</a>(out,in,mx);
00378   
00379                 <font class="comment">// lets find new left-bottom corner</font>
00380   
00381   <font class="keywordflow">if</font>(out[XL]&lt;out[XR])
00382     cx=out[XL];
00383   <font class="keywordflow">else</font>
00384     cx=out[XR];
00385   
00386   <font class="keywordflow">if</font>(out[YB]&lt;out[YT])
00387     cy=out[YB];
00388   <font class="keywordflow">else</font>
00389     cy=out[YT];
00390   
00391   
00392 }<font class="comment">// Pattern::findNewLeftBottom  //</font>
00393 
00394 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00395"></a><a class="code" href="class_transparency.html#a1">00395</a> <a class="code" href="class_transparency.html#a0">Transparency::Transparency</a>(<font class="keywordtype">int</font> sh,<font class="keywordtype">int</font> sv):sizeHor(sh),sizeVer(sv)
00396 <font class="comment">//</font>
00397 <font class="comment">//</font>
00398 {
00399   verGridMap = <font class="keyword">new</font> transGridType [sv];
00400   horGridMap = <font class="keyword">new</font> transGridType [sh];
00401   memset(horGridMap,0,sizeHor*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>));
00402   memset(verGridMap,0,sizeVer*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>));
00403 
00404 }<font class="comment">// Transparency::Transparency  //</font>
00405 
00406 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00407"></a><a class="code" href="class_transparency.html#a3">00407</a> <a class="code" href="class_transparency.html">Transparency</a>&amp; <a class="code" href="class_transparency.html#a3">Transparency::operator =</a>(<font class="keyword">const</font> <a class="code" href="class_transparency.html">Transparency</a>&amp; other)
00408 <font class="comment">//</font>
00409 <font class="comment">//</font>
00410 {
00411   sizeVer=other.sizeVer;
00412   sizeHor=other.sizeHor;
00413   verGridMap = <font class="keyword">new</font> transGridType [sizeVer];
00414   horGridMap = <font class="keyword">new</font> transGridType [sizeHor];
00415   memcpy(horGridMap,other.horGridMap,sizeHor*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>));
00416   memcpy(verGridMap,other.verGridMap,sizeVer*<font class="keyword">sizeof</font>(<font class="keywordtype">char</font>));
00417   <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00418 }<font class="comment">// Transparency::Transparency  //</font>
00419 
00420 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00421"></a><a class="code" href="class_transparency.html#a2">00421</a> <a class="code" href="class_transparency.html#a2">Transparency::~Transparency</a>()
00422 <font class="comment">//</font>
00423 <font class="comment">//</font>
00424 {
00425   <font class="keyword">delete</font> verGridMap;
00426   <font class="keyword">delete</font> horGridMap;
00427 
00428 }<font class="comment">// Transparency::~Transparency  //</font>
00429 
00430 
00431 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00432"></a><a class="code" href="class_transparency.html#a5">00432</a> <a class="code" href="class_transparency.html">Transparency</a>* <a class="code" href="class_transparency.html#a5">Transparency::transform</a>(<font class="keywordtype">short</font>* mtx)
00433 <font class="comment">//</font>
00434 <font class="comment">// It creates a copy of itself but after applying matrix operation</font>
00435 <font class="comment">// specified in mtx. </font>
00436 <font class="comment">// First we have to recognize kind of necessary transformations</font>
00437 <font class="comment">// For real examples only 4 kinds of mirror axes may exist</font>
00438 <font class="comment">//</font>
00439 <font class="comment">//      axis            matrix       descr.        verGridMap horGridMap </font>
00440 <font class="comment">//  --------------------------------------------------------------------  </font>
00441 <font class="comment">//  - no transform.   [ 1, 0, 0, 1]  nothing         nothing  nothing</font>
00442 <font class="comment">//  - horizontal      [ 1, 0, 0,-1]  mx              reverse  nothing</font>
00443 <font class="comment">//  - vertical        [-1, 0, 0, 1]  my              nothing  reverse</font>
00444 <font class="comment">//  - y = x           [ 0, 1, 0, 1]  mx &amp; rotate     hor.     ver.</font>
00445 <font class="comment">//  - y = -x + b      [ 0,-1,-1, 0]  my &amp; rotate     rev.hor. rev.ver.</font>
00446 
00447 {
00448   Boolean reverseHor=<font class="keyword">false</font>,reverseVer=<font class="keyword">false</font>,doSwitch=<font class="keyword">false</font>;
00449 
00450   <font class="keywordflow">if</font> ( mtx[A11] == 0)
00451     doSwitch=<font class="keyword">true</font>;
00452   <font class="keywordflow">if</font> ( mtx[A11] == -1 || mtx[A12] == -1)
00453     reverseHor=<font class="keyword">true</font>;
00454   <font class="keywordflow">if</font> ( mtx[A12] == 1 || mtx[A22]== -1)
00455     reverseVer=<font class="keyword">true</font>;
00456 
00457                 <font class="comment">// so now when we know what we </font>
00458                 <font class="comment">// should do let\'s do it</font>
00459   <a class="code" href="class_transparency.html">Transparency</a>* output;
00460   transGridType* srcPtr;
00461 
00462   <font class="keywordflow">if</font>(doSwitch)
00463     output = <font class="keyword">new</font> Transparency(sizeVer,sizeHor);
00464   <font class="keywordflow">else</font>
00465     output = <font class="keyword">new</font> Transparency(sizeHor,sizeVer);
00466 
00467                 <font class="comment">// first horGridMap</font>
00468   <font class="keywordflow">if</font>(doSwitch)
00469     srcPtr = verGridMap;
00470   <font class="keywordflow">else</font>
00471     srcPtr = horGridMap;
00472 
00473   <font class="keywordtype">int</font> i;
00474 
00475   <font class="keywordflow">for</font>(i=0;i&lt;output-&gt;sizeHor;i++)
00476   {
00477     <font class="keywordflow">if</font>(reverseHor)
00478       output-&gt;horGridMap[i]=srcPtr[output-&gt;sizeHor-i-1];
00479     <font class="keywordflow">else</font>
00480       output-&gt;horGridMap[i]=srcPtr[i];
00481   }
00482 
00483                 <font class="comment">// and the same for vertical map</font>
00484 
00485   <font class="keywordflow">if</font>(doSwitch)
00486     srcPtr = horGridMap;
00487   <font class="keywordflow">else</font>
00488     srcPtr = verGridMap;
00489   
00490 
00491   <font class="keywordflow">for</font>(i=0;i&lt;output-&gt;sizeVer;i++)
00492   {
00493     <font class="keywordflow">if</font>(reverseVer)
00494       output-&gt;verGridMap[i]=srcPtr[output-&gt;sizeVer-i-1];
00495     <font class="keywordflow">else</font>
00496       output-&gt;verGridMap[i]=srcPtr[i];
00497   }
00498 
00499                 <font class="comment">// done.</font>
00500 
00501   <font class="keywordflow">return</font> output;
00502 
00503 }<font class="comment">// Transparency::transform  //</font>
00504 
00505 
00506 
00507 <font class="comment">//----------------------------------------------------------------------------</font>
<a name="l00508"></a><a class="code" href="class_transparency.html#a4">00508</a> <font class="keywordtype">int</font> <a class="code" href="class_transparency.html#a4">Transparency::freeTracks</a>(<font class="keywordtype">int</font> dir)
00509 <font class="comment">//</font>
00510 <font class="comment">// Calculates number of free tracks in direction "dir".</font>
00511 {
00512   transGridType* ptr;
00513   transGridType* end;
00514 
00515   <font class="keywordflow">if</font>(dir == VER)
00516   {
00517     ptr=horGridMap;
00518     end=ptr+sizeHor;
00519   }
00520   <font class="keywordflow">else</font>
00521   {
00522     ptr=verGridMap;
00523     end=ptr+sizeVer;
00524   }
00525 
00526   <font class="keywordtype">int</font> sum=0;
00527 
00528   <font class="keywordflow">for</font>(;ptr&lt;end;ptr++)
00529     sum+=!(*ptr);
00530 
00531   <font class="keywordflow">return</font> sum;
00532 }<font class="comment">// Transparency::freeTracks  //</font>
00533 
</div></pre><hr><address><small>Generated at Thu Sep 28 15:38:01 2000 for madonna by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=110 height=53></a>1.1.5 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-2000</small></address>
</body>
</html>
